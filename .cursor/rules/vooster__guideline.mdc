---
description:
globs:
alwaysApply: true
---
# 모두의 유니폼 - Code Guidelines

## 1. Project Overview

This project is a responsive web service built with Next.js, TypeScript, and Supabase to facilitate custom uniform and merchandise creation for individuals and small groups. It uses a conversational questionnaire for quick quotes, real-time operator assignment, and social proof (reviews) to maximize conversion rates. The architecture emphasizes a component-based approach with a clear separation of concerns between the frontend (Next.js), backend (Supabase Edge Functions), and database (Supabase PostgreSQL).

Key architectural decisions:
*   Frontend: Next.js for SSR/SSG, React components, TailwindCSS for styling.
*   Backend: Supabase Edge Functions for API endpoints and serverless logic.
*   Database: Supabase PostgreSQL with RLS for data persistence and security.

## 2. Core Principles

*   **Maintainability:** Code should be easy to understand, modify, and extend by any team member.
*   **Readability:** Code should be clear, concise, and well-documented for easy comprehension.
*   **Testability:** Code should be designed to be easily tested with unit and integration tests.
*   **Performance:** Code should be optimized for speed and efficiency, considering both frontend and backend performance.
*   **Security:** Code should be written with security in mind to prevent vulnerabilities and protect user data.

## 3. Language-Specific Guidelines

### TypeScript

*   **File Organization:**
    *   Group related components, types, and utilities into directories.
    *   Use a consistent naming convention for files and directories (e.g., `camelCase` for variables, `PascalCase` for components).
*   **Import/Dependency Management:**
    *   Use absolute imports for internal modules and relative imports for local files within the same module.
    *   Avoid circular dependencies.
    *   Explicitly declare all dependencies in `package.json`.
*   **Error Handling:**
    *   Use `try...catch` blocks for handling potential errors.
    *   Create custom error classes for specific error scenarios.
    *   Log errors with sufficient context for debugging.

### Next.js

*   **File Organization:**
    *   Utilize the `pages` directory for route-based components.
    *   Use the `components` directory for reusable UI components.
    *   Place API routes in the `pages/api` directory.
*   **Data Fetching:**
    *   Use `getServerSideProps` for server-side rendering of dynamic data.
    *   Use `getStaticProps` for static site generation with data fetching at build time.
    *   Use `SWR` or `React Query` for client-side data fetching and caching.
*   **API Routes:**
    *   Handle API requests and responses with appropriate HTTP status codes.
    *   Validate request data and handle errors gracefully.

### TailwindCSS

*   **Class Naming:**
    *   Follow TailwindCSS's utility-first approach.
    *   Use consistent spacing and sizing conventions.
    *   Create custom CSS classes only when necessary and avoid duplicating existing TailwindCSS utilities.
*   **Configuration:**
    *   Customize the `tailwind.config.js` file to define custom colors, fonts, and other design tokens.
    *   Use the theme object to ensure consistency across the application.

### Supabase

*   **Database Interactions:**
    *   Use the Supabase client library for interacting with the PostgreSQL database.
    *   Utilize Row Level Security (RLS) policies to enforce access control.
    *   Optimize database queries for performance.
*   **Edge Functions:**
    *   Use Edge Functions for serverless backend logic.
    *   Handle API requests and responses with appropriate HTTP status codes.
    *   Secure Edge Functions with authentication and authorization.
*   **Storage:**
    *   Use Supabase Storage for storing images and other files.
    *   Configure appropriate access control policies.

## 4. Code Style Rules

### MUST Follow:

*   **Naming Conventions:**
    *   Variables: `camelCase` (e.g., `userName`, `totalCount`)
    *   Functions: `camelCase` (e.g., `getUserData`, `calculateTotal`)
    *   Components: `PascalCase` (e.g., `UserProfile`, `ProductCard`)
    *   Constants: `UPPER_SNAKE_CASE` (e.g., `API_URL`, `MAX_ITEMS`)
    *   Rationale: Consistent naming improves readability and maintainability.

*   **Code Formatting:**
    *   Use Prettier for automatic code formatting.
    *   Configure Prettier to use consistent indentation, line length, and spacing.
    *   Rationale: Consistent formatting reduces noise and makes code easier to read.

*   **Comments:**
    *   Write clear and concise comments to explain complex logic or non-obvious code.
    *   Use JSDoc-style comments for documenting functions and components.
    *   Rationale: Comments help other developers understand the purpose and functionality of the code.

*   **Error Handling:**
    *   Use `try...catch` blocks to handle potential errors.
    *   Log errors with sufficient context for debugging.
    *   Display user-friendly error messages to the user.
    *   Rationale: Proper error handling prevents unexpected crashes and provides a better user experience.

*   **State Management:**
    *   Use React Context for simple state management needs.
    *   Consider Zustand for more complex state management scenarios.
    *   Rationale: Choosing the right state management solution improves performance and maintainability.

*   **API Interactions:**
    *   Use a consistent API client (e.g., `axios`, `fetch`) for making API requests.
    *   Handle API errors gracefully.
    *   Use environment variables for API endpoints and other sensitive information.
    *   Rationale: Consistent API interactions improve code reusability and maintainability.

*   **Component Structure:**
    *   Create small, reusable components.
    *   Separate presentation logic from business logic.
    *   Use props for passing data to components.
    *   Rationale: Component-based architecture promotes code reusability and maintainability.

*   **Typescript Usage:**
    *   Use explicit types wherever possible.
    *   Define custom types for data structures.
    *   Use interfaces for defining object shapes.
    *   Rationale: Typescript increases code reliability and maintainability.

*   **TailwindCSS Usage:**
    *   Use TailwindCSS utility classes for styling.
    *   Avoid writing custom CSS unless absolutely necessary.
    *   Use the `theme` object in `tailwind.config.js` for consistent styling.
    *   Rationale: TailwindCSS promotes consistent styling and reduces the amount of custom CSS code.

### MUST NOT Do:

*   **Global Variables:**
    *   MUST NOT use global variables.
    *   Rationale: Global variables can lead to naming conflicts and unexpected side effects.

*   **Nested Callbacks:**
    *   MUST NOT use deeply nested callbacks.
    *   Rationale: Nested callbacks can make code difficult to read and maintain ("callback hell"). Use `async/await` instead.

*   **Magic Numbers/Strings:**
    *   MUST NOT use magic numbers or strings directly in the code.
    *   Rationale: Magic numbers and strings make code less readable and harder to maintain. Define constants instead.

*   **Console.log in Production:**
    *   MUST NOT leave `console.log` statements in production code.
    *   Rationale: `console.log` statements can expose sensitive information and impact performance.

*   **Ignoring Errors:**
    *   MUST NOT ignore errors.
    *   Rationale: Ignoring errors can lead to unexpected behavior and make debugging difficult. Handle errors gracefully or re-throw them.

*   **Complex Conditional Logic:**
    *   MUST NOT use overly complex conditional logic.
    *   Rationale: Complex conditional logic can make code difficult to understand and test. Refactor into smaller, more manageable functions.

*   **Direct DOM Manipulation:**
    *   MUST NOT directly manipulate the DOM unless absolutely necessary.
    *   Rationale: Direct DOM manipulation can interfere with React's virtual DOM and lead to performance issues. Use React's state management and component lifecycle methods instead.

*   **Duplicated Code:**
    *   MUST NOT duplicate code.
    *   Rationale: Duplicated code makes maintenance more difficult. Refactor into reusable functions or components.

## 5. Architecture Patterns

*   **Component/Module Structure:**
    *   Follow a modular architecture with well-defined components and modules.
    *   Group related components, types, and utilities into directories.
    *   Use a consistent naming convention for files and directories.
*   **Data Flow Patterns:**
    *   Use unidirectional data flow.
    *   Pass data down to components via props.
    *   Use callbacks for components to communicate with their parents.
*   **State Management Conventions:**
    *   Use React Context for simple state management needs.
    *   Consider Zustand for more complex state management scenarios.
    *   Avoid unnecessary state updates.
*   **API Design Standards:**
    *   Follow RESTful API principles.
    *   Use appropriate HTTP methods (GET, POST, PUT, DELETE).
    *   Return appropriate HTTP status codes.
    *   Use JSON for request and response bodies.

```typescript
// MUST: Example of a well-defined component with clear props and types
interface UserProfileProps {
  name: string;
  age: number;
  email: string;
}

const UserProfile: React.FC<UserProfileProps> = ({ name, age, email }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
    </div>
  );
};

// Explanation: This component is well-defined with clear props and types, making it easy to understand and reuse.
```

```typescript
// MUST NOT: Example of a component with complex logic and no clear separation of concerns
const BadComponent = () => {
  const [data, setData] = React.useState(null);

  React.useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => {
        // Complex data manipulation and rendering logic here
        setData(data);
      });
  }, []);

  return (
    <div>
      {/* Complex rendering logic based on the data */}
    </div>
  );
};

// Explanation: This component mixes data fetching, data manipulation, and rendering logic, making it difficult to test and maintain.  It should be broken down into smaller, more manageable components with a clear separation of concerns.
```

