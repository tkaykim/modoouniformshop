{
  "rules": [
    {
      "type": "prd",
      "content": "# 모두의 유니폼 – PRD (Product Requirements Document)\n\n## 1. 제품 개요\n단체복·굿즈 제작을 원하는 개인/소규모 단체가 대화형 설문으로 3분 이내에 견적 가능 여부를 확인하고, 운영팀이 실시간 문의를 배정·관리하며, 사회적 증거(실제 리뷰)로 전환율을 극대화하는 반응형 웹 서비스.\n\n## 2. 목표 & 성공 지표\n| 목표 | KPI (MVP 기준) |\n|------|---------------|\n|빠른 상담 접수| 설문 완주율 ≥ 70% , 평균 설문 완료 시간 ≤ 3분|\n|전환율 향상| 리뷰 노출 후 문의 전환율 ≥ 15%|\n|운영 효율| 문의 배정 평균 지연 ≤ 30분, 1건 처리 평균 시간 ≤ 5분|\n|고객 만족| 문의 진행 알림 열람율 ≥ 60%, CS 만족도 ≥ 4.5/5|\n\n## 3. 주요 사용자(Persona)\n1. **개인/소규모 단체 대표(김소연, 28세)**  \n   - 목표: 회식·MT용 단체복 최소 견적으로 빠르게 확인하고 주문 진행.  \n   - 페인: 여러 업체 비교/전화 문의가 번거로움.\n2. **학교·동아리 총무(박민호, 22세)**  \n   - 목표: 기념 티셔츠를 예산 내 빠르게 제작, 진행 상황을 실시간 파악.  \n   - 페인: 학사 일정 내 완료 여부 불확실, 연락 지연.\n3. **운영 담당자(이현진, 34세)**  \n   - 목표: 실시간 문의를 빠르게 분류·배정하고 답변.  \n   - 페인: 스프레드시트 수작업 관리에 따른 누락 발생.\n\n## 4. 핵심 기능\n| 구분 | 기능 | 상세 설명 | 우선순위 |\n|------|------|-----------|-----------|\n|고객|대화형 상담 설문| 9단계 설문, 낙관적 저장, 이탈 복원| Must|\n|고객|리뷰 리스트/상세| 실사진 LCP 최적화, 모달 탐색| Must|\n|고객|문의 진행 알림| 카카오톡/이메일 Webhook, 상태 변화 시 전송| Should|\n|운영|문의 대시보드| 권한별 필터, 상태/담당 수정, KPI 위젯| Must|\n|운영|리뷰 CRUD| 이미지 업로드, 표시시각 설정| Must|\n|운영|데모 보드| 경영 지표 예시 시각화| Could|\n\n## 5. 기능 상세\n### 5.1 대화형 상담 설문\n- 세션 ID 로컬 저장, 스텝별 zod 검증.\n- 완료 시 `finalizeInquiry` → 상태 `awaiting_reply`.\n\n### 5.2 리뷰 노출\n- Home 최근 4건 프리뷰 → 목록 → 상세 모달/페이지.\n- 조회수 RPC & 로컬 폴백.\n\n### 5.3 진행 상황 알림 (신규)\n- 트리거: 상태 변경(`awaiting_reply`→`in_progress`→`completed`).\n- 채널: 카카오 알림톡(템플릿) + 이메일(SendGrid) 병행.\n- 설정: Admin에서 템플릿 관리, 알림 온/오프.\n\n### 5.4 Admin 문의 대시보드\n- 실시간 Supabase Realtime 구독(선택) 또는 폴링.\n- 담당자 드롭다운, 일괄 삭제, 행 펼치기 편집.\n\n### 5.5 권한·보안\n- Supabase Auth, roles: `admin`, `agent`, `public`.\n- RLS 정책 테이블별 정의.\n\n## 6. MVP 범위\n- Home, 리뷰, 설문 플로우(1~3,8,9단계) 완전 동작\n- Admin 문의/리뷰 관리 기본 CRUD\n- 카카오톡/이메일 알림 1개 템플릿 적용(`awaiting_reply`→`in_progress`)\n\n## 7. 비(非)기능 요구사항\n- 반응형: 모바일 뷰 360px 이상 대응\n- 접근성: 키보드 탐색, 충분한 대비\n- 성능: Core Web Vitals LCP ≤ 2.5s, CLS ≤ 0.1\n- 보안: Supabase RLS, env secret 관리\n\n## 8. 리스크 & 대비\n| 리스크 | 대응 |\n|---------|------|\n|카카오 알림톡 심사 지연| MVP는 이메일만 먼저 적용|\n|이미지 대용량 업로드| 5MB 제한 + Squoosh 압축|\n|실시간 구독 트래픽 증가| 초기엔 폴링, 추후 옵션화|\n\n## 9. 향후 로드맵(인크리멘털)\n1. 설문 4~7단계 활성화 & 가격 계산 로직\n2. 리뷰 검색/필터 고도화\n3. 다국어 지원(영/일)\n4. 모바일 전용 PWA 패키징\n\n---\nDocument saved by Vooster (AI PM)",
      "writedAt": "2025-08-14T18:20:08.735Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: 단체복 및 굿즈 제작을 원하는 개인/소규모 단체를 위한 반응형 웹 서비스 개발. 대화형 설문을 통해 빠른 견적 확인을 지원하고, 운영팀은 실시간 문의 배정 및 관리를 수행합니다. 사회적 증거(리뷰)를 활용하여 전환율을 극대화합니다.\n- **핵심 기술 스택**: Next.js, TypeScript, TailwindCSS, Supabase (PostgreSQL, Storage, Auth, Edge Functions), Vercel, Toss Payments\n- **주요 기술 목표**: 빠른 상담 접수, 전환율 향상, 운영 효율성 증대, 고객 만족도 향상\n- **주요 기술 가정**: 안정적인 Supabase 서비스, 카카오 알림톡 연동 가능, 사용자 네트워크 환경 양호\n\n## 2. 기술 스택\n\n| 카테고리 | 기술 / 라이브러리 | 이유 (프로젝트 선택 이유) |\n|---|---|---|\n| 프레임워크 | Next.js | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 지원, SEO 최적화, 빠른 초기 로딩 속도 |\n| 언어 | TypeScript | 안정적인 코드 유지보수, 타입 안정성, 개발 생산성 향상 |\n| 스타일링 | TailwindCSS | 빠른 UI 개발, 일관된 디자인 시스템, 반응형 디자인 지원 |\n| 데이터베이스 | Supabase (PostgreSQL) | 안정적인 관계형 데이터베이스, 실시간 데이터 구독 지원, 확장성 |\n| 스토리지 | Supabase Storage | 이미지 및 파일 저장, CDN 통합 |\n| 인증 | Supabase Auth | 간편한 사용자 인증 및 권한 관리, 소셜 로그인 지원 |\n| 서버리스 함수 | Supabase Edge Functions | 백엔드 로직 처리, API 엔드포인트 구현 |\n| 배포 | Vercel | 간편한 배포, 자동 스케일링, 글로벌 CDN |\n| 결제 | Toss Payments | 간편한 결제 API, 다양한 결제 수단 지원 |\n| 알림 | Kakao 알림톡, SendGrid | 사용자 알림 발송, 빠른 정보 전달 |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n*   **Frontend (Next.js)**:\n    *   사용자 인터페이스 및 사용자 경험 제공\n    *   대화형 설문, 리뷰 목록/상세 페이지, 진행 상황 알림 기능 구현\n    *   서브 빌딩 블록:\n        *   UI 컴포넌트 (React 컴포넌트)\n        *   페이지 라우팅 (Next.js 라우터)\n        *   상태 관리 (React Context, Zustand)\n*   **Backend (Supabase Edge Functions)**:\n    *   API 엔드포인트 제공, 데이터 처리 로직 수행\n    *   설문 데이터 저장, 리뷰 CRUD, 알림 발송 기능 구현\n    *   서브 빌딩 블록:\n        *   API 핸들러 (Edge Function)\n        *   데이터베이스 쿼리 (PostgreSQL)\n        *   외부 서비스 연동 (Kakao 알림톡, SendGrid)\n*   **Database (Supabase PostgreSQL)**:\n    *   데이터 저장 및 관리\n    *   사용자 정보, 설문 데이터, 리뷰 데이터 저장\n    *   서브 빌딩 블록:\n        *   테이블 스키마 정의\n        *   RLS (Row Level Security) 정책\n*   **Admin Dashboard (Next.js)**:\n    *   운영 담당자를 위한 관리 인터페이스 제공\n    *   문의 관리, 리뷰 관리, 데모 보드 기능 구현\n    *   서브 빌딩 블록:\n        *   UI 컴포넌트 (React 컴포넌트)\n        *   데이터 그리드\n        *   차트\n\n### 최상위 컴포넌트 상호 작용 다이어그램\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase Edge Functions)]\n    B --> C[Database (Supabase PostgreSQL)]\n    A --> D[Toss Payments API]\n    B --> E[Kakao 알림톡 API]\n    B --> F[SendGrid API]\n    G[Admin Dashboard (Next.js)] --> B\n```\n\n*   **Frontend (Next.js) <-> Backend (Supabase Edge Functions)**: 사용자는 웹 페이지를 통해 설문 작성, 리뷰 조회 등의 작업을 수행하며, Frontend는 API를 통해 Backend에 데이터를 요청하고 응답을 받습니다.\n*   **Backend (Supabase Edge Functions) <-> Database (Supabase PostgreSQL)**: Backend는 API 요청을 받아 데이터베이스에 데이터를 저장하거나 조회합니다. Supabase Edge Functions는 데이터베이스와 상호 작용하여 필요한 데이터를 처리합니다.\n*   **Frontend (Next.js) <-> Toss Payments API**: 결제 시 Frontend는 Toss Payments API를 호출하여 결제를 진행합니다.\n*   **Backend (Supabase Edge Functions) <-> Kakao 알림톡 API/SendGrid API**: 상태 변경 등의 이벤트 발생 시 Backend는 Kakao 알림톡 API 또는 SendGrid API를 호출하여 사용자에게 알림을 발송합니다.\n*   **Admin Dashboard (Next.js) <-> Backend (Supabase Edge Functions)**: 관리자는 Admin Dashboard를 통해 문의 관리, 리뷰 관리 등의 작업을 수행하며, Frontend는 API를 통해 Backend에 데이터를 요청하고 응답을 받습니다.\n\n### 코드 구성 및 규칙\n\n**도메인 기반 조직 전략**\n- **도메인 분리**: 사용자 관리, 결제 처리, 콘텐츠 관리 등 비즈니스 도메인/제한된 컨텍스트별로 코드 구성\n- **계층 기반 아키텍처**: 프레젠테이션, 비즈니스 로직, 데이터 액세스, 인프라 등 별개의 계층으로 관심사 분리\n- **기능 기반 모듈**: 기술적 관심사별로 분리하기보다는 관련 기능을 함께 그룹화\n- **공유 컴포넌트**: 전용 공유 모듈에서 일반 유틸리티, 유형 및 재사용 가능한 컴포넌트 사용\n\n**보편적인 파일 및 폴더 구조**\n```\n/\n├── components/               # 재사용 가능한 UI 컴포넌트\n│   ├── Button.tsx\n│   ├── Input.tsx\n│   └── ...\n├── pages/                    # Next.js 페이지 라우팅\n│   ├── index.tsx             # 홈 페이지\n│   ├── inquiry.tsx           # 설문 페이지\n│   ├── reviews.tsx           # 리뷰 페이지\n│   └── admin/              # 관리자 페이지\n│       ├── dashboard.tsx\n│       └── ...\n├── utils/                    # 유틸리티 함수\n│   ├── api.ts                # API 호출 함수\n│   ├── validation.ts         # 유효성 검사 함수\n│   └── ...\n├── types/                    # TypeScript 타입 정의\n│   ├── inquiry.ts            # 설문 관련 타입\n│   ├── review.ts             # 리뷰 관련 타입\n│   └── ...\n├── services/                 # 외부 서비스 연동 로직\n│   ├── kakao-alert.ts        # 카카오 알림톡 연동\n│   ├── sendgrid.ts           # SendGrid 연동\n│   └── ...\n├── public/                   # 정적 파일 (이미지, 폰트 등)\n│   ├── images/\n│   └── ...\n├── .env.local                # 환경 변수\n├── next.config.js            # Next.js 설정 파일\n├── tailwind.config.js        # TailwindCSS 설정 파일\n├── tsconfig.json             # TypeScript 설정 파일\n└── ...\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: API 요청/응답 패턴 (RESTful API)\n- **데이터베이스 상호 작용**: Supabase 클라이언트 라이브러리 사용, RLS 정책 적용\n- **외부 서비스 통합**: Kakao 알림톡 API, SendGrid API 연동\n- **실시간 통신**: Supabase Realtime 구독 (선택 사항, 폴링으로 대체 가능)\n- **데이터 동기화**: 분산된 컴포넌트 간의 일관성 패턴\n\n## 4. 성능 및 최적화 전략\n- 이미지 최적화: 이미지 크기 조정, 압축, Lazy Loading 적용\n- 코드 분할: Next.js Dynamic Import를 사용하여 초기 로딩 속도 개선\n- 캐싱: Supabase Edge Functions 캐싱, 브라우저 캐싱 활용\n- 데이터베이스 쿼리 최적화: 인덱싱, 쿼리 성능 분석\n- CDN 활용: Supabase Storage CDN, Vercel CDN 활용\n\n## 5. 구현 로드맵 및 마일스톤\n\n### 1단계: 기반 구축 (MVP 구현)\n- **핵심 인프라**: 기본 시스템 설정 및 기반 컴포넌트 구축\n- **필수 기능**: 최소 실행 가능 제품 기능 구현 (홈, 리뷰, 설문 플로우(1~3,8,9단계) 완전 동작)\n- **기본 보안**: 기본적인 보안 구현 (Supabase RLS, env secret 관리)\n- **개발 환경**: 개발 환경 설정 및 CI/CD 기본 설정\n- **예상 완료 기간**: 4주\n\n### 2단계: 기능 개선\n- **고급 기능**: MVP 이상의 확장된 기능 구현 (Admin 문의/리뷰 관리 기본 CRUD, 카카오톡/이메일 알림 1개 템플릿 적용(`awaiting_reply`→`in_progress`))\n- **성능 최적화**: 시스템 성능 개선\n- **보안 강화**: 고급 보안 기능 및 규정 준수 (카카오 알림톡 심사 완료)\n- **모니터링 구현**: 종합적인 관찰 가능성 설정\n- **예상 완료 기간**: 4주\n\n## 6. 위험 평가 및 완화 전략\n\n### 기술적 위험 분석\n- **기술 위험**: 잠재적인 기술적 문제 및 복잡성 문제 (Supabase, Next.js, Vercel에 대한 의존성)\n- **성능 위험**: 확장성 및 성능 병목 현상 (트래픽 증가, 데이터베이스 쿼리 성능)\n- **보안 위험**: 잠재적인 보안 취약점 및 공격 벡터 (Supabase RLS 설정 오류, XSS, CSRF 공격)\n- **통합 위험**: 타사 서비스 종속성 및 실패 지점 (Kakao 알림톡, SendGrid, Toss Payments)\n- **완화 전략**:\n    - 기술 스택에 대한 충분한 학습 및 숙지\n    - 성능 테스트 및 최적화\n    - 보안 취약점 점검 및 보안 강화\n    - 타사 서비스 장애 대비 대체 방안 마련\n\n### 프로젝트 전달 위험\n- **일정 위험**: 개발 일정 문제 및 종속성 (카카오 알림톡 심사 지연)\n- **리소스 위험**: 팀 역량 및 기술 전문성 요구 사항 (Supabase 전문가 부족)\n- **품질 위험**: 코드 품질 및 테스트 커버리지 문제 (테스트 코드 부족)\n- **배포 위험**: 프로덕션 배포 및 환경 문제 (Vercel 배포 문제)\n- **비상 계획**:\n    - 카카오 알림톡 심사 지연 시 이메일 알림으로 대체\n    - Supabase 전문가 확보 또는 교육\n    - 테스트 코드 작성 및 코드 리뷰 강화\n    - Vercel 배포 문제 발생 시 대체 배포 플랫폼 고려\n",
      "writedAt": "2025-08-14T18:20:08.735Z"
    },
    {
      "type": "guideline",
      "content": "# 모두의 유니폼 - Code Guidelines\n\n## 1. Project Overview\n\nThis project is a responsive web service built with Next.js, TypeScript, and Supabase to facilitate custom uniform and merchandise creation for individuals and small groups. It uses a conversational questionnaire for quick quotes, real-time operator assignment, and social proof (reviews) to maximize conversion rates. The architecture emphasizes a component-based approach with a clear separation of concerns between the frontend (Next.js), backend (Supabase Edge Functions), and database (Supabase PostgreSQL).\n\nKey architectural decisions:\n*   Frontend: Next.js for SSR/SSG, React components, TailwindCSS for styling.\n*   Backend: Supabase Edge Functions for API endpoints and serverless logic.\n*   Database: Supabase PostgreSQL with RLS for data persistence and security.\n\n## 2. Core Principles\n\n*   **Maintainability:** Code should be easy to understand, modify, and extend by any team member.\n*   **Readability:** Code should be clear, concise, and well-documented for easy comprehension.\n*   **Testability:** Code should be designed to be easily tested with unit and integration tests.\n*   **Performance:** Code should be optimized for speed and efficiency, considering both frontend and backend performance.\n*   **Security:** Code should be written with security in mind to prevent vulnerabilities and protect user data.\n\n## 3. Language-Specific Guidelines\n\n### TypeScript\n\n*   **File Organization:**\n    *   Group related components, types, and utilities into directories.\n    *   Use a consistent naming convention for files and directories (e.g., `camelCase` for variables, `PascalCase` for components).\n*   **Import/Dependency Management:**\n    *   Use absolute imports for internal modules and relative imports for local files within the same module.\n    *   Avoid circular dependencies.\n    *   Explicitly declare all dependencies in `package.json`.\n*   **Error Handling:**\n    *   Use `try...catch` blocks for handling potential errors.\n    *   Create custom error classes for specific error scenarios.\n    *   Log errors with sufficient context for debugging.\n\n### Next.js\n\n*   **File Organization:**\n    *   Utilize the `pages` directory for route-based components.\n    *   Use the `components` directory for reusable UI components.\n    *   Place API routes in the `pages/api` directory.\n*   **Data Fetching:**\n    *   Use `getServerSideProps` for server-side rendering of dynamic data.\n    *   Use `getStaticProps` for static site generation with data fetching at build time.\n    *   Use `SWR` or `React Query` for client-side data fetching and caching.\n*   **API Routes:**\n    *   Handle API requests and responses with appropriate HTTP status codes.\n    *   Validate request data and handle errors gracefully.\n\n### TailwindCSS\n\n*   **Class Naming:**\n    *   Follow TailwindCSS's utility-first approach.\n    *   Use consistent spacing and sizing conventions.\n    *   Create custom CSS classes only when necessary and avoid duplicating existing TailwindCSS utilities.\n*   **Configuration:**\n    *   Customize the `tailwind.config.js` file to define custom colors, fonts, and other design tokens.\n    *   Use the theme object to ensure consistency across the application.\n\n### Supabase\n\n*   **Database Interactions:**\n    *   Use the Supabase client library for interacting with the PostgreSQL database.\n    *   Utilize Row Level Security (RLS) policies to enforce access control.\n    *   Optimize database queries for performance.\n*   **Edge Functions:**\n    *   Use Edge Functions for serverless backend logic.\n    *   Handle API requests and responses with appropriate HTTP status codes.\n    *   Secure Edge Functions with authentication and authorization.\n*   **Storage:**\n    *   Use Supabase Storage for storing images and other files.\n    *   Configure appropriate access control policies.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Naming Conventions:**\n    *   Variables: `camelCase` (e.g., `userName`, `totalCount`)\n    *   Functions: `camelCase` (e.g., `getUserData`, `calculateTotal`)\n    *   Components: `PascalCase` (e.g., `UserProfile`, `ProductCard`)\n    *   Constants: `UPPER_SNAKE_CASE` (e.g., `API_URL`, `MAX_ITEMS`)\n    *   Rationale: Consistent naming improves readability and maintainability.\n\n*   **Code Formatting:**\n    *   Use Prettier for automatic code formatting.\n    *   Configure Prettier to use consistent indentation, line length, and spacing.\n    *   Rationale: Consistent formatting reduces noise and makes code easier to read.\n\n*   **Comments:**\n    *   Write clear and concise comments to explain complex logic or non-obvious code.\n    *   Use JSDoc-style comments for documenting functions and components.\n    *   Rationale: Comments help other developers understand the purpose and functionality of the code.\n\n*   **Error Handling:**\n    *   Use `try...catch` blocks to handle potential errors.\n    *   Log errors with sufficient context for debugging.\n    *   Display user-friendly error messages to the user.\n    *   Rationale: Proper error handling prevents unexpected crashes and provides a better user experience.\n\n*   **State Management:**\n    *   Use React Context for simple state management needs.\n    *   Consider Zustand for more complex state management scenarios.\n    *   Rationale: Choosing the right state management solution improves performance and maintainability.\n\n*   **API Interactions:**\n    *   Use a consistent API client (e.g., `axios`, `fetch`) for making API requests.\n    *   Handle API errors gracefully.\n    *   Use environment variables for API endpoints and other sensitive information.\n    *   Rationale: Consistent API interactions improve code reusability and maintainability.\n\n*   **Component Structure:**\n    *   Create small, reusable components.\n    *   Separate presentation logic from business logic.\n    *   Use props for passing data to components.\n    *   Rationale: Component-based architecture promotes code reusability and maintainability.\n\n*   **Typescript Usage:**\n    *   Use explicit types wherever possible.\n    *   Define custom types for data structures.\n    *   Use interfaces for defining object shapes.\n    *   Rationale: Typescript increases code reliability and maintainability.\n\n*   **TailwindCSS Usage:**\n    *   Use TailwindCSS utility classes for styling.\n    *   Avoid writing custom CSS unless absolutely necessary.\n    *   Use the `theme` object in `tailwind.config.js` for consistent styling.\n    *   Rationale: TailwindCSS promotes consistent styling and reduces the amount of custom CSS code.\n\n### MUST NOT Do:\n\n*   **Global Variables:**\n    *   MUST NOT use global variables.\n    *   Rationale: Global variables can lead to naming conflicts and unexpected side effects.\n\n*   **Nested Callbacks:**\n    *   MUST NOT use deeply nested callbacks.\n    *   Rationale: Nested callbacks can make code difficult to read and maintain (\"callback hell\"). Use `async/await` instead.\n\n*   **Magic Numbers/Strings:**\n    *   MUST NOT use magic numbers or strings directly in the code.\n    *   Rationale: Magic numbers and strings make code less readable and harder to maintain. Define constants instead.\n\n*   **Console.log in Production:**\n    *   MUST NOT leave `console.log` statements in production code.\n    *   Rationale: `console.log` statements can expose sensitive information and impact performance.\n\n*   **Ignoring Errors:**\n    *   MUST NOT ignore errors.\n    *   Rationale: Ignoring errors can lead to unexpected behavior and make debugging difficult. Handle errors gracefully or re-throw them.\n\n*   **Complex Conditional Logic:**\n    *   MUST NOT use overly complex conditional logic.\n    *   Rationale: Complex conditional logic can make code difficult to understand and test. Refactor into smaller, more manageable functions.\n\n*   **Direct DOM Manipulation:**\n    *   MUST NOT directly manipulate the DOM unless absolutely necessary.\n    *   Rationale: Direct DOM manipulation can interfere with React's virtual DOM and lead to performance issues. Use React's state management and component lifecycle methods instead.\n\n*   **Duplicated Code:**\n    *   MUST NOT duplicate code.\n    *   Rationale: Duplicated code makes maintenance more difficult. Refactor into reusable functions or components.\n\n## 5. Architecture Patterns\n\n*   **Component/Module Structure:**\n    *   Follow a modular architecture with well-defined components and modules.\n    *   Group related components, types, and utilities into directories.\n    *   Use a consistent naming convention for files and directories.\n*   **Data Flow Patterns:**\n    *   Use unidirectional data flow.\n    *   Pass data down to components via props.\n    *   Use callbacks for components to communicate with their parents.\n*   **State Management Conventions:**\n    *   Use React Context for simple state management needs.\n    *   Consider Zustand for more complex state management scenarios.\n    *   Avoid unnecessary state updates.\n*   **API Design Standards:**\n    *   Follow RESTful API principles.\n    *   Use appropriate HTTP methods (GET, POST, PUT, DELETE).\n    *   Return appropriate HTTP status codes.\n    *   Use JSON for request and response bodies.\n\n```typescript\n// MUST: Example of a well-defined component with clear props and types\ninterface UserProfileProps {\n  name: string;\n  age: number;\n  email: string;\n}\n\nconst UserProfile: React.FC<UserProfileProps> = ({ name, age, email }) => {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      <p>Email: {email}</p>\n    </div>\n  );\n};\n\n// Explanation: This component is well-defined with clear props and types, making it easy to understand and reuse.\n```\n\n```typescript\n// MUST NOT: Example of a component with complex logic and no clear separation of concerns\nconst BadComponent = () => {\n  const [data, setData] = React.useState(null);\n\n  React.useEffect(() => {\n    fetch('/api/data')\n      .then(res => res.json())\n      .then(data => {\n        // Complex data manipulation and rendering logic here\n        setData(data);\n      });\n  }, []);\n\n  return (\n    <div>\n      {/* Complex rendering logic based on the data */}\n    </div>\n  );\n};\n\n// Explanation: This component mixes data fetching, data manipulation, and rendering logic, making it difficult to test and maintain.  It should be broken down into smaller, more manageable components with a clear separation of concerns.\n```\n",
      "writedAt": "2025-08-14T18:20:08.735Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-14T18:20:08.735Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-14T18:20:08.735Z"
    }
  ]
}